# -*- coding: utf-8 -*-
"""main code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eboAS3QEy1e4Ur5hzvKXxqOA_7JsnP3i
"""

import streamlit as st
import numpy as np
import plotly.graph_objects as go

# Function to compute Q matrix from material properties
def compute_q_matrix(E1, E2, G12, nu12):
    nu21 = nu12 * (E2 / E1)
    Q11 = E1 / (1 - nu12 * nu21)
    Q12 = (nu12 * E2) / (1 - nu12 * nu21)
    Q22 = E2 / (1 - nu12 * nu21)
    Q66 = G12
    Q = np.array([
        [Q11, Q12, 0],
        [Q12, Q22, 0],
        [0, 0, Q66]
    ])
    return Q

# Function to compute ABD matrices for each lamina
def compute_abd(angles, thicknesses, Q):
    n_layers = len(angles)
    A = np.zeros((3, 3))
    B = np.zeros((3, 3))
    D = np.zeros((3, 3))

    z = np.zeros(n_layers + 1)  # Layer boundaries
    for i in range(1, n_layers + 1):
        z[i] = z[i-1] + thicknesses[i-1]

    for i in range(n_layers):
        T_inv = transformation_matrix_inv(angles[i])
        Q_bar = T_inv @ Q @ T_inv.T
        z_top = z[i+1]
        z_bot = z[i]
        A += Q_bar * (z_top - z_bot)
        B += Q_bar * (z_top**2 - z_bot**2) / 2
        D += Q_bar * (z_top**3 - z_bot**3) / 3

    return A, B, D

# Transformation matrix for a ply angle
def transformation_matrix_inv(theta):
    theta_rad = np.radians(theta)
    c = np.cos(theta_rad)
    s = np.sin(theta_rad)
    T_inv = np.array([
        [c**2, s**2, 2*c*s],
        [s**2, c**2, -2*c*s],
        [-c*s, c*s, c**2 - s**2]
    ])
    return T_inv

# Streamlit app
st.title("Classical Laminate Theory App")

# Insert image below the title
st.image("CLT1.jpg", caption="Classical Laminate Theory", use_column_width=True)

# Sidebar inputs for material properties
st.sidebar.title("Material Properties")
E1 = st.sidebar.number_input("E1 (GPa) - Longitudinal Modulus", value=181.0)
E2 = st.sidebar.number_input("E2 (GPa) - Transverse Modulus", value=10.3)
G12 = st.sidebar.number_input("G12 (GPa) - In-Plane Shear Modulus", value=7.17)
nu12 = st.sidebar.number_input("nu12 - Poisson's Ratio", value=0.28)

# Compute the Q matrix based on material properties
Q = compute_q_matrix(E1, E2, G12, nu12)

# Input fields for the laminate data
st.sidebar.title("Laminate Inputs")
n_layers = st.sidebar.number_input("Number of Layers", min_value=1, value=3)
angles = [st.sidebar.number_input(f"Layer {i+1} Angle (degrees)", value=0) for i in range(n_layers)]
thicknesses = [st.sidebar.number_input(f"Layer {i+1} Thickness (mm)", value=5.0) for i in range(n_layers)]

# Calculate ABD matrices
A, B, D = compute_abd(angles, thicknesses, Q)

# Display ABD matrices
st.subheader("Extensional Stiffness Matrix [A]")
st.write(A)

st.subheader("Coupling Stiffness Matrix [B]")
st.write(B)

st.subheader("Bending Stiffness Matrix [D]")
st.write(D)

# Plot the strain distribution across the thickness
z_positions = np.linspace(-sum(thicknesses)/2, sum(thicknesses)/2, n_layers+1)
strain_top = np.array([1e-6, 2e-6, 3e-6])  # Replace with actual strain values from calculations
strain_bottom = np.array([3e-6, 1e-6, 2e-6])

# Plotting using Plotly
fig = go.Figure()

# Top layer strain
fig.add_trace(go.Scatter(
    x=strain_top, y=z_positions[:-1],
    mode='lines+markers',
    name='Top Surface Strain',
    line=dict(color='blue')
))

# Bottom layer strain
fig.add_trace(go.Scatter(
    x=strain_bottom, y=z_positions[1:],
    mode='lines+markers',
    name='Bottom Surface Strain',
    line=dict(color='red')
))

fig.update_layout(title="Strain Distribution Across the Laminate",
                  xaxis_title="Strain",
                  yaxis_title="Position through thickness (z)",
                  height=600)
st.plotly_chart(fig)
